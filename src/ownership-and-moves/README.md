# 所有权与移动

说到内存管理, 我们希望编程语言具备两个特点:
- 希望内存能在我们选定的时机及时释放, 这使我们能够控制内存的消耗;
- 在对象被释放后, 我们绝不希望继续使用指向它的指针, 这是未定义行为, 会导致崩溃和安全漏洞。

但上述场景似乎难以兼顾：只要指向值的指针仍然存在，释放这个值必然会让这些指针悬空。几乎所有的主流编程语言都只能在这两个阵营中”二选一“，这取决于他们从中放弃了哪一项。
- “安全优先”的阵营会通过垃圾回收机制来管理内存，在所有指向对象的可达指针消失后，自动释放对象。他通过简单地保留对象，直到再也没有指向它们的指针为止，来消除悬空指针。几乎所有的现代语言都属于这个阵营，从Python、Javascript和Ruby到Java、C#和Haskell。
但是依赖垃圾回收，就意味着放弃了对于释放对象时机的精准控制，完全委托给回收器代管。一般来说，垃圾回收器就像奇怪的野兽般难以捉摸，要理解内存为何没在预期的时机释放可能颇具挑战。
- ”控制优先“的阵营会让你自己负责释放内存。程序的内存消耗完全掌握在你的手中，避免悬空指针也完全成了你的责任。C和C++是这个阵营中仅有的两种主流语言。

如果你永不犯错，这当然是很好的选择，但事实证明，只要是人就会犯错。从已收集的安全报告数据来看，指针滥用一直都是引发问题的罪魁祸首。

Rust的目标是既安全又高效，所以这两种妥协都是无法接受的。但如果很容易兼得，那应该早就有人做到了。看来我们需要做一些根本性的变革。